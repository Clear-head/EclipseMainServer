<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>데이터 관리</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="layout">
        <aside class="sidebar">
            <div class="sidebar__brand">오늘 뭐하지?</div>
            <nav class="sidebar__nav" aria-label="사이드바">
                <a class="sidebar__tab" href="dashboard.html">통계 관리</a>
                <a class="sidebar__tab is-active" href="data.html">데이터 관리</a>
                <a class="sidebar__tab" href="users.html">사용자 관리</a>
            </nav>
        </aside>
        <div class="content">
            <header>
                <h1>데이터 관리</h1>
            </header>
            <main class="data-main">
                <section class="summary-card">
                    <h2>크롤링 태그 관리</h2>
                    <div class="card__body">
                        <div class="tag-tabs">
                            <button class="tag-tab is-active" data-category="restaurant">음식점</button>
                            <button class="tag-tab" data-category="cafe">카페</button>
                            <button class="tag-tab" data-category="content">콘텐츠</button>
                        </div>
                        <div class="tag-chart-container">
                            <canvas id="tagChart" aria-label="카테고리별 태그 분포"></canvas>
                        </div>
                    </div>
                </section>

                <section class="summary-card">
                    <h2>사용자 인기 장소 현황</h2>
                    <div class="card__body">
                        <div class="table-container">
                            <table id="popularPlacesTable">
                                <thead>
                                    <tr>
                                        <th>순위</th>
                                        <th>매장타입</th>
                                        <th>이름</th>
                                        <th>구</th>
                                        <th>서브카테고리</th>
                                        <th>방문횟수</th>
                                    </tr>
                                </thead>
                                <tbody id="popularPlacesTableBody">
                                    <!-- 데이터가 로드되면 여기에 동적으로 추가됩니다 -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

                <section class="summary-card district-card">
                    <h2>서울특별시 자치구 별 매장 수</h2>
                    <div class="card__body">
                        <div class="tag-tabs">
                            <button class="tag-tab is-active" data-category="restaurant">음식점</button>
                            <button class="tag-tab" data-category="cafe">카페</button>
                            <button class="tag-tab" data-category="content">콘텐츠</button>
                        </div>
                        <div class="district-chart-container">
                            <canvas id="districtChart" aria-label="서울특별시 자치구별 매장 수"></canvas>
                        </div>
                    </div>
                </section>
            </main>
        </div>
    </div>
</body>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="api.js"></script>
<script>
    // 카테고리별 태그 데이터 (API에서 로드)
    let tagData = {
        restaurant: { labels: [], data: [] },
        cafe: { labels: [], data: [] },
        content: { labels: [], data: [] }
    };

    // 카테고리 타입 매핑
    const categoryTypeMap = {
        restaurant: '0',
        cafe: '1',
        content: '2'
    };

    let tagChart = null;
    let districtChart = null;

    // DB에서 받은 데이터를 변환하는 함수
    // SQL 쿼리 결과: [{gu: '강남구', 음식점: 268, 카페: 124, 콘텐츠: 86}, ...]
    function transformDistrictData(dbData) {
        const labels = dbData.map(row => row.gu);
        const restaurant = dbData.map(row => row.음식점 || 0);
        const cafe = dbData.map(row => row.카페 || 0);
        const content = dbData.map(row => row.콘텐츠 || 0);
        
        return {
            labels: labels,
            restaurant: restaurant,
            cafe: cafe,
            content: content
        };
    }

    // 전역 변수로 업데이트 가능하도록 설정 (API에서 데이터를 받아올 때까지 null)
    let currentDistrictData = null;

    // 데이터의 최소값과 최대값에 따라 X축 설정을 자동 계산하는 함수
    function calculateXAxisSettings(data) {
        if (!data || data.length === 0) {
            return { min: 0, max: 2000, stepSize: 2000 };
        }

        const minDataValue = Math.min(...data);
        const maxDataValue = Math.max(...data);
        
        // 최대값이 0이면 기본값 반환
        if (maxDataValue === 0) {
            return { min: 0, max: 2000, stepSize: 2000 };
        }

        // 최소값은 항상 0으로 설정
        const minValue = 0;
        
        // 최대값을 천 단위로 올림 (약 5% 여유 공간 추가)
        const maxWithPadding = Math.ceil(maxDataValue * 1.05);
        const maxRoundedToThousand = Math.ceil(maxWithPadding / 1000) * 1000;
        
        // 최대값에 따라 적절한 간격 결정 (천 단위 기준, 간격을 넓게 설정)
        let stepSize;
        let finalMax;
        
        if (maxRoundedToThousand <= 10000) {
            // 10000 이하: 2000 단위
            stepSize = 2000;
            finalMax = Math.ceil(maxRoundedToThousand / 2000) * 2000;
        } else if (maxRoundedToThousand <= 20000) {
            // 20000 이하: 5000 단위
            stepSize = 5000;
            finalMax = Math.ceil(maxRoundedToThousand / 5000) * 5000;
        } else if (maxRoundedToThousand <= 50000) {
            // 50000 이하: 10000 단위
            stepSize = 10000;
            finalMax = Math.ceil(maxRoundedToThousand / 10000) * 10000;
        } else if (maxRoundedToThousand <= 100000) {
            // 100000 이하: 20000 단위
            stepSize = 20000;
            finalMax = Math.ceil(maxRoundedToThousand / 20000) * 20000;
        } else {
            // 100000 초과: 50000 단위
            stepSize = 50000;
            finalMax = Math.ceil(maxRoundedToThousand / 50000) * 50000;
        }

        // 최대값이 너무 작으면 최소값 보장
        if (finalMax < 2000) {
            finalMax = 2000;
            stepSize = 2000;
        }

        return {
            min: minValue,
            max: finalMax,
            stepSize: stepSize
        };
    }

    function createTagChart(category) {
        const canvas = document.getElementById('tagChart');
        if (!canvas) {
            console.error('tagChart canvas를 찾을 수 없습니다.');
            return;
        }

        const ctx = canvas.getContext('2d');
        const data = tagData[category];

        // 데이터가 없으면 메시지 표시
        if (!data || !data.labels || data.labels.length === 0) {
            console.warn(`태그 데이터가 없습니다. 카테고리: ${category}`);
            // 기존 차트가 있으면 제거
            if (tagChart) {
                tagChart.destroy();
                tagChart = null;
            }
            // 캔버스 크기 설정
            const container = canvas.parentElement;
            if (container) {
                canvas.width = container.clientWidth || 800;
                canvas.height = container.clientHeight || 400;
            }
            // 캔버스에 메시지 표시
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#52606d';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('데이터가 없습니다.', canvas.width / 2, canvas.height / 2);
            return;
        }

        // X축 설정 계산
        const axisSettings = calculateXAxisSettings(data.data);
        const minValue = axisSettings.min;
        const maxValue = axisSettings.max;
        const stepSize = axisSettings.stepSize;

        // 기존 차트가 있으면 데이터만 업데이트 (애니메이션 효과)
        if (tagChart) {
            // 먼저 0으로 설정
            tagChart.data.labels = data.labels;
            tagChart.data.datasets[0].data = data.data.map(() => 0);
            // x축 최소값, 최대값 업데이트
            tagChart.options.scales.x.min = minValue;
            tagChart.options.scales.x.max = maxValue;
            tagChart.options.scales.x.ticks.stepSize = stepSize;
            tagChart.update('none'); // 애니메이션 없이 즉시 업데이트

            // 짧은 딜레이 후 실제 데이터로 업데이트 (애니메이션 효과)
            setTimeout(() => {
                tagChart.data.datasets[0].data = data.data;
                tagChart.update();
            }, 50);
            return;
        }

        // 첫 번째 차트 생성 시 0에서 시작
        const baseData = data.data.map(() => 0);
        tagChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: data.labels,
                datasets: [{
                    label: '태그 수',
                    data: baseData,
                    backgroundColor: '#FF8126',
                    borderRadius: 6,
                    categoryPercentage: 0.7,
                    barPercentage: 0.8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                animation: {
                    duration: 800,
                    easing: 'easeOutQuart'
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label(context) {
                                return `${context.parsed.x}개`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: false,
                        min: minValue,
                        max: maxValue,
                        ticks: {
                            color: '#52606d',
                            font: {
                                size: 11
                            },
                            stepSize: stepSize,
                            maxTicksLimit: 12,  // 최대 눈금 개수 제한
                            callback: (value) => {
                                // 0은 표시하지 않음
                                if (value === 0) {
                                    return '';
                                }
                                // 천 단위로 반올림하여 정수로 표시
                                const rounded = Math.round(value / 1000) * 1000;
                                // 숫자 포맷팅 (천 단위 구분자)
                                return `${rounded.toLocaleString('ko-KR')}개`;
                            }
                        },
                        grid: {
                            color: 'rgba(82, 96, 109, 0.12)',
                            drawBorder: false
                        }
                    },
                    y: {
                        ticks: {
                            color: '#52606d',
                            font: {
                                size: 12
                            }
                        },
                        grid: {
                            display: false
                        }
                    }
                }
            }
        });

        // 실제 데이터로 업데이트 (애니메이션 효과)
        setTimeout(() => {
            tagChart.data.datasets[0].data = data.data;
            tagChart.update();
        }, 100);
    }

    // 데이터의 최대값에 따라 Y축 최대값과 간격을 자동 계산하는 함수
    function calculateAxisSettings(data) {
        if (!data || data.length === 0) {
            return { maxValue: 100, stepSize: 10 };
        }

        const maxDataValue = Math.max(...data);
        
        // 최대값이 0이면 기본값 반환
        if (maxDataValue === 0) {
            return { maxValue: 100, stepSize: 10 };
        }

        // 최대값에 여유 공간을 주기 위해 1.1배 (10% 여유)
        const maxValueWithPadding = Math.ceil(maxDataValue * 1.1);

        // 최대값에 따라 적절한 간격 계산
        // 1. 최대값의 자릿수 확인
        const digits = Math.floor(Math.log10(maxValueWithPadding));
        const magnitude = Math.pow(10, digits);
        
        // 2. 최대값을 magnitude로 나눈 값에 따라 간격 결정
        const normalizedValue = maxValueWithPadding / magnitude;
        
        let stepSize;
        let roundedMax;
        
        if (normalizedValue <= 1) {
            // 1 이하: 0.2, 0.5, 1 단위
            if (normalizedValue <= 0.2) {
                stepSize = 0.2 * magnitude;
                roundedMax = Math.ceil(maxValueWithPadding / (0.2 * magnitude)) * (0.2 * magnitude);
            } else if (normalizedValue <= 0.5) {
                stepSize = 0.5 * magnitude;
                roundedMax = Math.ceil(maxValueWithPadding / (0.5 * magnitude)) * (0.5 * magnitude);
            } else {
                stepSize = 1 * magnitude;
                roundedMax = Math.ceil(maxValueWithPadding / magnitude) * magnitude;
            }
        } else if (normalizedValue <= 2) {
            // 1~2: 0.5 단위
            stepSize = 0.5 * magnitude;
            roundedMax = Math.ceil(maxValueWithPadding / (0.5 * magnitude)) * (0.5 * magnitude);
        } else if (normalizedValue <= 5) {
            // 2~5: 1 단위
            stepSize = 1 * magnitude;
            roundedMax = Math.ceil(maxValueWithPadding / magnitude) * magnitude;
        } else {
            // 5 이상: 2 단위
            stepSize = 2 * magnitude;
            roundedMax = Math.ceil(maxValueWithPadding / (2 * magnitude)) * (2 * magnitude);
        }

        // 최소 간격 보장 (너무 작은 간격 방지)
        if (stepSize < 1) {
            stepSize = 1;
            roundedMax = Math.ceil(maxValueWithPadding);
        }

        // 최대값이 너무 작으면 최소값 보장
        if (roundedMax < 10) {
            roundedMax = 10;
            stepSize = 2;
        }

        console.log(`[DEBUG] 데이터 최대값: ${maxDataValue}, 계산된 Y축 최대값: ${roundedMax}, 간격: ${stepSize}`);

        return {
            maxValue: roundedMax,
            stepSize: stepSize
        };
    }

    function createDistrictChart(category) {
        const canvas = document.getElementById('districtChart');
        if (!canvas) {
            console.error('districtChart canvas를 찾을 수 없습니다.');
            return;
        }

        // 데이터가 없으면 메시지 표시
        if (!currentDistrictData) {
            console.warn('차트 데이터가 없습니다. API에서 데이터를 먼저 로드하세요.');
            // 기존 차트가 있으면 제거
            if (districtChart) {
                districtChart.destroy();
                districtChart = null;
            }
            // 캔버스 크기 설정
            const container = canvas.parentElement;
            if (container) {
                canvas.width = container.clientWidth || 800;
                canvas.height = container.clientHeight || 400;
            }
            // 캔버스에 메시지 표시
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#52606d';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('데이터가 없습니다.', canvas.width / 2, canvas.height / 2);
            return;
        }

        const ctx = canvas.getContext('2d');
        const labels = currentDistrictData.labels;
        const data = currentDistrictData[category];

        // 데이터의 최대값에 따라 Y축 설정 자동 계산
        const axisSettings = calculateAxisSettings(data);
        const maxValue = axisSettings.maxValue;
        const stepSize = axisSettings.stepSize;

        // 기존 차트가 있으면 데이터만 업데이트 (애니메이션 효과)
        if (districtChart) {
            districtChart.data.labels = labels;
            districtChart.data.datasets[0].data = data.map(() => 0);
            // y축 최대값 업데이트
            districtChart.options.scales.y.max = maxValue;
            districtChart.options.scales.y.ticks.stepSize = stepSize;
            districtChart.update('none');
            setTimeout(() => {
                districtChart.data.datasets[0].data = data;
                districtChart.update();
            }, 50);
            return;
        }

        // 첫 번째 차트 생성 시 0에서 시작
        const baseData = data.map(() => 0);
        districtChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: '매장 수',
                    data: baseData,
                    backgroundColor: '#FF8126',
                    borderRadius: 6,
                    categoryPercentage: 0.7,
                    barPercentage: 0.8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: 800,
                    easing: 'easeOutQuart'
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label(context) {
                                return `${context.parsed.y}개`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        ticks: {
                            color: '#52606d',
                            font: {
                                size: 11
                            },
                            maxRotation: 45,
                            minRotation: 45
                        },
                        grid: {
                            display: false
                        }
                    },
                    y: {
                        beginAtZero: true,
                        max: maxValue,
                        ticks: {
                            color: '#52606d',
                            font: {
                                size: 11
                            },
                            stepSize: stepSize,
                            callback: (value) => `${value}개`
                        },
                        grid: {
                            color: 'rgba(82, 96, 109, 0.12)',
                            drawBorder: false
                        }
                    }
                }
            }
        });

        // 실제 데이터로 업데이트 (애니메이션 효과)
        setTimeout(() => {
            districtChart.data.datasets[0].data = data;
            districtChart.update();
        }, 100);
    }

    // 태그 데이터 로드 함수
    async function loadTagData(category) {
        try {
            const categoryType = categoryTypeMap[category];
            const data = await api.getTagStatistics(categoryType);
            
            if (!data || !Array.isArray(data) || data.length === 0) {
                console.warn(`태그 데이터가 없습니다. 카테고리: ${category}`);
                tagData[category] = {
                    labels: [],
                    data: []
                };
                return tagData[category];
            }
            
            // 데이터 변환: [{name: '태그명', total_count: 123}, ...] -> {labels: [...], data: [...]}
            tagData[category] = {
                labels: data.map(item => item.name || ''),
                data: data.map(item => item.total_count || 0)
            };
            
            return tagData[category];
        } catch (error) {
            console.error(`태그 데이터 로드 오류 (${category}):`, error);
            // 에러 발생 시 빈 데이터로 설정
            tagData[category] = {
                labels: [],
                data: []
            };
            return tagData[category];
        }
    }

    // 인기 장소 데이터 로드 및 테이블 렌더링 함수
    async function loadPopularPlaces() {
        try {
            const data = await api.getPopularPlaces();
            const tbody = document.getElementById('popularPlacesTableBody');
            
            if (!tbody) {
                console.error('테이블 tbody를 찾을 수 없습니다.');
                return;
            }

            // 기존 내용 초기화
            tbody.innerHTML = '';

            if (!data || data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px;">데이터가 없습니다.</td></tr>';
                return;
            }

            // 데이터를 순위와 함께 테이블에 추가
            data.forEach((place, index) => {
                const row = document.createElement('tr');
                row.setAttribute('data-row-index', index);
                
                // 행 구성
                row.innerHTML = `
                    <td>${place.순위 || index + 1}</td>
                    <td>${place.매장타입 || ''}</td>
                    <td>${place.이름 || ''}</td>
                    <td>${place.구 || ''}</td>
                    <td>${place.서브카테고리 || ''}</td>
                    <td>${place.방문횟수 || 0}회</td>
                `;
                
                tbody.appendChild(row);
            });
        } catch (error) {
            console.error('인기 장소 데이터 로드 오류:', error);
            const tbody = document.getElementById('popularPlacesTableBody');
            if (tbody) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px; color: #F44336;">데이터를 불러오는 중 오류가 발생했습니다.</td></tr>';
            }
        }
    }

    // 탭 전환 기능
    document.addEventListener('DOMContentLoaded', async () => {
        // 태그 관리 카드의 탭 전환 기능 (district-card가 아닌 카드의 탭만 선택)
        const tagTabs = document.querySelectorAll('.summary-card:not(.district-card) .tag-tab');
        tagTabs.forEach(tab => {
            tab.addEventListener('click', async () => {
                // 같은 카드 내의 모든 탭에서 is-active 제거
                const parentCard = tab.closest('.summary-card');
                const sameCardTabs = parentCard.querySelectorAll('.tag-tab');
                sameCardTabs.forEach(t => t.classList.remove('is-active'));
                // 클릭한 탭에 is-active 추가
                tab.classList.add('is-active');
                // 해당 카테고리의 데이터 로드 및 차트 생성
                const category = tab.getAttribute('data-category');
                await loadTagData(category);
                createTagChart(category);
            });
        });

        // 초기 태그 데이터 로드 및 차트 생성 (음식점)
        await loadTagData('restaurant');
        createTagChart('restaurant');

        // 인기 장소 데이터 로드 및 테이블 렌더링
        await loadPopularPlaces();
        
        // 서울시 자치구 차트 탭 전환 기능
        const districtTabs = document.querySelectorAll('.district-card .tag-tab');
        districtTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // 같은 카드 내의 모든 탭에서 is-active 제거
                const parentCard = tab.closest('.district-card');
                const sameCardTabs = parentCard.querySelectorAll('.tag-tab');
                sameCardTabs.forEach(t => t.classList.remove('is-active'));
                // 클릭한 탭에 is-active 추가
                tab.classList.add('is-active');
                // 해당 카테고리의 차트 생성
                const category = tab.getAttribute('data-category');
                createDistrictChart(category);
            });
        });
        
        // DB에서 데이터 가져오기 (API 호출)
        console.log('API 모듈 확인:', typeof api, typeof api?.getDistrictStats);
        
        if (typeof api !== 'undefined' && api.getDistrictStats) {
            console.log('API 호출 시작...');
            api.getDistrictStats()
                .then(dbData => {
                    console.log('받은 데이터:', dbData);
                    if (dbData && Array.isArray(dbData) && dbData.length > 0) {
                        console.log('데이터 변환 시작, 개수:', dbData.length);
                        // 쿼리 결과를 현재 형식으로 변환
                        currentDistrictData = transformDistrictData(dbData);
                        console.log('변환된 데이터:', currentDistrictData);
                        
                        // 차트 생성 (음식점)
                        createDistrictChart('restaurant');
                    } else {
                        console.error('데이터가 없거나 빈 배열입니다. 받은 데이터:', dbData);
                        // 차트 영역에 에러 메시지 표시
                        const canvas = document.getElementById('districtChart');
                        if (canvas) {
                            const container = canvas.parentElement;
                            if (container) {
                                canvas.width = container.clientWidth || 800;
                                canvas.height = container.clientHeight || 400;
                            }
                            const ctx = canvas.getContext('2d');
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = '#52606d';
                            ctx.font = '16px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('데이터를 불러올 수 없습니다.', canvas.width / 2, canvas.height / 2);
                            ctx.fillText('서버에 데이터가 없을 수 있습니다.', canvas.width / 2, canvas.height / 2 + 20);
                        }
                    }
                })
                .catch(error => {
                    console.error('데이터 로딩 오류 상세:', error);
                    console.error('에러 타입:', error.constructor.name);
                    console.error('에러 메시지:', error.message);
                    // 차트 영역에 에러 메시지 표시
                    const canvas = document.getElementById('districtChart');
                    if (canvas) {
                        const container = canvas.parentElement;
                        if (container) {
                            canvas.width = container.clientWidth || 800;
                            canvas.height = container.clientHeight || 400;
                        }
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#F44336';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('API 연결 오류', canvas.width / 2, canvas.height / 2 - 20);
                        ctx.fillText(error.message || '서버를 확인하세요.', canvas.width / 2, canvas.height / 2);
                        ctx.fillText('콘솔을 확인하세요.', canvas.width / 2, canvas.height / 2 + 20);
                    }
                });
        } else {
            console.error('API 모듈을 찾을 수 없습니다.');
            console.error('api 객체:', typeof api);
            console.error('api.getDistrictStats:', typeof api?.getDistrictStats);
            // 차트 영역에 에러 메시지 표시
            const canvas = document.getElementById('districtChart');
            if (canvas) {
                const container = canvas.parentElement;
                if (container) {
                    canvas.width = container.clientWidth || 800;
                    canvas.height = container.clientHeight || 400;
                }
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#F44336';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('API 모듈을 찾을 수 없습니다.', canvas.width / 2, canvas.height / 2 - 10);
                ctx.fillText('api.js 파일이 로드되었는지 확인하세요.', canvas.width / 2, canvas.height / 2 + 10);
            }
        }
    });
</script>
</html>
